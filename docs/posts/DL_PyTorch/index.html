<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Juan Isaula">
<meta name="dcterms.date" content="2025-07-01">

<title>Deep Learning – Juan Isaula</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-b4960eac7a6f9fac35b610a7dc5af25a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Deep Learning – Juan Isaula">
<meta property="og:description" content="PyTorch">
<meta property="og:image" content="https://j-isaula.github.io/Web_JI/posts/DL_PyTorch/fondo.webp">
<meta property="og:site_name" content="Juan Isaula">
<meta property="og:locale" content="en_US">
<meta name="twitter:title" content="Deep Learning – Juan Isaula">
<meta name="twitter:description" content="PyTorch">
<meta name="twitter:image" content="https://j-isaula.github.io/Web_JI/posts/DL_PyTorch/fondo.webp">
<meta name="twitter:creator" content="@isaula_im">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Juan Isaula</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../papers"> 
<span class="menu-text">Articles</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cursos_impartidos"> 
<span class="menu-text">UNAH Courses</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Dasboard"> 
<span class="menu-text">Dashboards</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Sobre_mi"> 
<span class="menu-text">Historias</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introducción-a-pytorch-biblioteca-de-deep-learning" id="toc-introducción-a-pytorch-biblioteca-de-deep-learning" class="nav-link active" data-scroll-target="#introducción-a-pytorch-biblioteca-de-deep-learning">Introducción a PyTorch (biblioteca de Deep Learning)</a>
  <ul class="collapse">
  <li><a href="#qué-es-deep-learning" id="toc-qué-es-deep-learning" class="nav-link" data-scroll-target="#qué-es-deep-learning">Qué es Deep Learning?</a></li>
  <li><a href="#pytorch-un-framework-del-deep-learning" id="toc-pytorch-un-framework-del-deep-learning" class="nav-link" data-scroll-target="#pytorch-un-framework-del-deep-learning">PyTorch: un framework del deep learning</a>
  <ul class="collapse">
  <li><a href="#atributos-de-los-tensores" id="toc-atributos-de-los-tensores" class="nav-link" data-scroll-target="#atributos-de-los-tensores">Atributos de los Tensores</a></li>
  </ul></li>
  <li><a href="#redes-neuronales-y-capas" id="toc-redes-neuronales-y-capas" class="nav-link" data-scroll-target="#redes-neuronales-y-capas">Redes Neuronales y Capas</a></li>
  <li><a href="#pesos-weights-y-sesgos-biases" id="toc-pesos-weights-y-sesgos-biases" class="nav-link" data-scroll-target="#pesos-weights-y-sesgos-biases">Pesos (weights) y Sesgos (biases)</a></li>
  <li><a href="#capaz-y-parámetros-ocultos" id="toc-capaz-y-parámetros-ocultos" class="nav-link" data-scroll-target="#capaz-y-parámetros-ocultos">Capaz y Parámetros Ocultos</a>
  <ul class="collapse">
  <li><a href="#apilamiento-de-capaz-con-nn.sequential" id="toc-apilamiento-de-capaz-con-nn.sequential" class="nav-link" data-scroll-target="#apilamiento-de-capaz-con-nn.sequential">Apilamiento de capaz con nn.Sequential()</a></li>
  <li><a href="#adición-de-capas" id="toc-adición-de-capas" class="nav-link" data-scroll-target="#adición-de-capas">Adición de capas</a></li>
  <li><a href="#las-capas-están-hechas-de-neuronas" id="toc-las-capas-están-hechas-de-neuronas" class="nav-link" data-scroll-target="#las-capas-están-hechas-de-neuronas">Las capas están hechas de neuronas</a></li>
  <li><a href="#parámetros-y-capacidad-del-modelo" id="toc-parámetros-y-capacidad-del-modelo" class="nav-link" data-scroll-target="#parámetros-y-capacidad-del-modelo">Parámetros y Capacidad del Modelo</a></li>
  <li><a href="#balance-entre-complejidad-y-eficiencia" id="toc-balance-entre-complejidad-y-eficiencia" class="nav-link" data-scroll-target="#balance-entre-complejidad-y-eficiencia">Balance entre complejidad y eficiencia</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#hiperparámetros-y-arquitectura-de-redes-neuronales" id="toc-hiperparámetros-y-arquitectura-de-redes-neuronales" class="nav-link" data-scroll-target="#hiperparámetros-y-arquitectura-de-redes-neuronales">Hiperparámetros y arquitectura de redes neuronales</a>
  <ul class="collapse">
  <li><a href="#funciones-de-activación" id="toc-funciones-de-activación" class="nav-link" data-scroll-target="#funciones-de-activación">Funciones de Activación</a>
  <ul class="collapse">
  <li><a href="#función-sigmoid" id="toc-función-sigmoid" class="nav-link" data-scroll-target="#función-sigmoid">Función Sigmoid</a></li>
  <li><a href="#función-softmax" id="toc-función-softmax" class="nav-link" data-scroll-target="#función-softmax">Función Softmax</a></li>
  </ul></li>
  <li><a href="#paso-hacia-adelante" id="toc-paso-hacia-adelante" class="nav-link" data-scroll-target="#paso-hacia-adelante">Paso hacia adelante</a>
  <ul class="collapse">
  <li><a href="#qué-es-una-paso-hacia-adelante-forward-pass" id="toc-qué-es-una-paso-hacia-adelante-forward-pass" class="nav-link" data-scroll-target="#qué-es-una-paso-hacia-adelante-forward-pass">Qué es una paso hacia adelante (Forward Pass)?</a></li>
  <li><a href="#clasificación-multi-class-forward-pass" id="toc-clasificación-multi-class-forward-pass" class="nav-link" data-scroll-target="#clasificación-multi-class-forward-pass">Clasificación Multi-Class: Forward Pass</a></li>
  <li><a href="#regresión-forward-pass" id="toc-regresión-forward-pass" class="nav-link" data-scroll-target="#regresión-forward-pass">Regresión: Forward Pass</a></li>
  </ul></li>
  <li><a href="#funciones-de-pérdida-para-evaluar-las-predicciones-del-modelo" id="toc-funciones-de-pérdida-para-evaluar-las-predicciones-del-modelo" class="nav-link" data-scroll-target="#funciones-de-pérdida-para-evaluar-las-predicciones-del-modelo">Funciones de Pérdida para Evaluar las Predicciones del Modelo</a>
  <ul class="collapse">
  <li><a href="#función-de-pérdida-cross-entropy-en-pytorch" id="toc-función-de-pérdida-cross-entropy-en-pytorch" class="nav-link" data-scroll-target="#función-de-pérdida-cross-entropy-en-pytorch">Función de Pérdida Cross Entropy en PyTorch</a></li>
  </ul></li>
  <li><a href="#utilizar-derivadas-para-actualizar-los-parámetros-del-modelo" id="toc-utilizar-derivadas-para-actualizar-los-parámetros-del-modelo" class="nav-link" data-scroll-target="#utilizar-derivadas-para-actualizar-los-parámetros-del-modelo">Utilizar derivadas para Actualizar los Parámetros del Modelo</a>
  <ul class="collapse">
  <li><a href="#funciones-convexas-y-no-convexas" id="toc-funciones-convexas-y-no-convexas" class="nav-link" data-scroll-target="#funciones-convexas-y-no-convexas">Funciones Convexas y No-Convexas</a></li>
  <li><a href="#conexión-de-derivadas-y-entrenamiento-de-modelos" id="toc-conexión-de-derivadas-y-entrenamiento-de-modelos" class="nav-link" data-scroll-target="#conexión-de-derivadas-y-entrenamiento-de-modelos">Conexión de derivadas y entrenamiento de modelos</a></li>
  <li><a href="#backpropagation-retropropagación" id="toc-backpropagation-retropropagación" class="nav-link" data-scroll-target="#backpropagation-retropropagación">Backpropagation (Retropropagación)</a></li>
  <li><a href="#actualizar-manualmente-los-parámetros-del-modelo" id="toc-actualizar-manualmente-los-parámetros-del-modelo" class="nav-link" data-scroll-target="#actualizar-manualmente-los-parámetros-del-modelo">Actualizar Manualmente los Parámetros del Modelo</a></li>
  <li><a href="#gradiente-descendente" id="toc-gradiente-descendente" class="nav-link" data-scroll-target="#gradiente-descendente">Gradiente Descendente</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#entrenar-una-red-neuronal-con-pytorch" id="toc-entrenar-una-red-neuronal-con-pytorch" class="nav-link" data-scroll-target="#entrenar-una-red-neuronal-con-pytorch">Entrenar una red neuronal con PyTorch</a>
  <ul class="collapse">
  <li><a href="#inmmersión-profunda-en-la-carga-de-datos" id="toc-inmmersión-profunda-en-la-carga-de-datos" class="nav-link" data-scroll-target="#inmmersión-profunda-en-la-carga-de-datos">Inmmersión profunda en la carga de datos</a></li>
  <li><a href="#tensordataset" id="toc-tensordataset" class="nav-link" data-scroll-target="#tensordataset">TensorDataset</a></li>
  <li><a href="#escribir-nuestro-primer-bucle-de-entrenamiento" id="toc-escribir-nuestro-primer-bucle-de-entrenamiento" class="nav-link" data-scroll-target="#escribir-nuestro-primer-bucle-de-entrenamiento">Escribir nuestro primer bucle de entrenamiento</a>
  <ul class="collapse">
  <li><a href="#entrenando-una-red-neuronal" id="toc-entrenando-una-red-neuronal" class="nav-link" data-scroll-target="#entrenando-una-red-neuronal">Entrenando una Red Neuronal</a></li>
  </ul></li>
  <li><a href="#funciones-de-activación-relu" id="toc-funciones-de-activación-relu" class="nav-link" data-scroll-target="#funciones-de-activación-relu">Funciones de Activación ReLU</a>
  <ul class="collapse">
  <li><a href="#limitaciones-de-sigmoid-y-softmax" id="toc-limitaciones-de-sigmoid-y-softmax" class="nav-link" data-scroll-target="#limitaciones-de-sigmoid-y-softmax">Limitaciones de Sigmoid y Softmax</a></li>
  <li><a href="#relu" id="toc-relu" class="nav-link" data-scroll-target="#relu">ReLU</a></li>
  <li><a href="#leaky-relu-relu-con-fugas" id="toc-leaky-relu-relu-con-fugas" class="nav-link" data-scroll-target="#leaky-relu-relu-con-fugas">Leaky ReLU (ReLU con fugas)</a></li>
  </ul></li>
  <li><a href="#tasa-de-aprendizaje" id="toc-tasa-de-aprendizaje" class="nav-link" data-scroll-target="#tasa-de-aprendizaje">Tasa de Aprendizaje</a>
  <ul class="collapse">
  <li><a href="#actualización-de-pesos-con-sgd" id="toc-actualización-de-pesos-con-sgd" class="nav-link" data-scroll-target="#actualización-de-pesos-con-sgd">Actualización de Pesos con SGD</a></li>
  <li><a href="#impaco-de-learning-rate-tasa-de-aprendizaje-óptima" id="toc-impaco-de-learning-rate-tasa-de-aprendizaje-óptima" class="nav-link" data-scroll-target="#impaco-de-learning-rate-tasa-de-aprendizaje-óptima">Impaco de learning rate: tasa de aprendizaje óptima</a></li>
  <li><a href="#impacto-de-learning-rate-tasa-de-aprendizaje-pequeña" id="toc-impacto-de-learning-rate-tasa-de-aprendizaje-pequeña" class="nav-link" data-scroll-target="#impacto-de-learning-rate-tasa-de-aprendizaje-pequeña">Impacto de learning rate tasa de aprendizaje pequeña</a></li>
  <li><a href="#impacto-learning-rate-tasa-de-aprendizaje-alto" id="toc-impacto-learning-rate-tasa-de-aprendizaje-alto" class="nav-link" data-scroll-target="#impacto-learning-rate-tasa-de-aprendizaje-alto">Impacto learning rate: tasa de aprendizaje alto</a></li>
  <li><a href="#sin-momentum" id="toc-sin-momentum" class="nav-link" data-scroll-target="#sin-momentum">Sin momentum</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#evaluación-y-mejora-de-los-modelos" id="toc-evaluación-y-mejora-de-los-modelos" class="nav-link" data-scroll-target="#evaluación-y-mejora-de-los-modelos">Evaluación y Mejora de los Modelos</a>
  <ul class="collapse">
  <li><a href="#inicialización-de-capas-y-aprendizaje-por-transferencia" id="toc-inicialización-de-capas-y-aprendizaje-por-transferencia" class="nav-link" data-scroll-target="#inicialización-de-capas-y-aprendizaje-por-transferencia">Inicialización de capas y aprendizaje por transferencia</a></li>
  <li><a href="#aprendizaje-por-transferencia" id="toc-aprendizaje-por-transferencia" class="nav-link" data-scroll-target="#aprendizaje-por-transferencia">Aprendizaje por Transferencia</a></li>
  <li><a href="#ajuste-fino" id="toc-ajuste-fino" class="nav-link" data-scroll-target="#ajuste-fino">Ajuste Fino</a></li>
  <li><a href="#evaluación-del-rendimiento-de-los-modelos" id="toc-evaluación-del-rendimiento-de-los-modelos" class="nav-link" data-scroll-target="#evaluación-del-rendimiento-de-los-modelos">Evaluación del Rendimiento de los Modelos</a>
  <ul class="collapse">
  <li><a href="#calculando-pérdida-de-entrenamiento" id="toc-calculando-pérdida-de-entrenamiento" class="nav-link" data-scroll-target="#calculando-pérdida-de-entrenamiento">Calculando Pérdida de Entrenamiento</a></li>
  <li><a href="#calculo-de-la-pérdida-de-validación" id="toc-calculo-de-la-pérdida-de-validación" class="nav-link" data-scroll-target="#calculo-de-la-pérdida-de-validación">Calculo de la pérdida de validación</a></li>
  <li><a href="#sobreajuste-o-overfitting" id="toc-sobreajuste-o-overfitting" class="nav-link" data-scroll-target="#sobreajuste-o-overfitting">Sobreajuste o Overfitting</a></li>
  <li><a href="#calculando-accuracy-con-torchmetrics" id="toc-calculando-accuracy-con-torchmetrics" class="nav-link" data-scroll-target="#calculando-accuracy-con-torchmetrics">Calculando accuracy con <code>torchmetrics</code></a></li>
  </ul></li>
  <li><a href="#lucha-contra-el-sobreajuste" id="toc-lucha-contra-el-sobreajuste" class="nav-link" data-scroll-target="#lucha-contra-el-sobreajuste">Lucha contra el Sobreajuste</a>
  <ul class="collapse">
  <li><a href="#regularización-usando-una-capa-dropout" id="toc-regularización-usando-una-capa-dropout" class="nav-link" data-scroll-target="#regularización-usando-una-capa-dropout">Regularización usando una capa dropout</a></li>
  <li><a href="#regularización-con-disminución-de-pesos" id="toc-regularización-con-disminución-de-pesos" class="nav-link" data-scroll-target="#regularización-con-disminución-de-pesos">Regularización con disminución de pesos</a></li>
  <li><a href="#aumentación-de-data" id="toc-aumentación-de-data" class="nav-link" data-scroll-target="#aumentación-de-data">Aumentación de Data</a></li>
  </ul></li>
  <li><a href="#mejorar-el-rendimiento-del-modelo" id="toc-mejorar-el-rendimiento-del-modelo" class="nav-link" data-scroll-target="#mejorar-el-rendimiento-del-modelo">Mejorar el Rendimiento del Modelo</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Deep Learning</h1>
<p class="subtitle lead">PyTorch</p>
  <div class="quarto-categories">
    <div class="quarto-category">Python</div>
    <div class="quarto-category">PyTorch</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Juan Isaula </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>El Deep Learning está en todas partes, desde las cámaras de los smartphones hasta los asistentes de vos o los vehículos autónomos. En este curso, descubriras esta potente tecnología y aprenderás a aprovecharla con <code>PyTorch</code>, una de las bibliotecas de aprendizaje profundo más populares. Al finalizar tu recorrido por este documento, serás capaz de aprovechar PyTorch para resolver problemas de clasificación y regresión utilizando el aprendizaje profundo.</p>
<section id="introducción-a-pytorch-biblioteca-de-deep-learning" class="level1">
<h1>Introducción a PyTorch (biblioteca de Deep Learning)</h1>
<p>Antes de comenzar a crear modelos complejos, te haré conocer PyTorch, un librería de aprendizaje profundo. Aprenderás a manipular tensores, crear estructuras de datos de PyTorch y construir tu primera red neuronal en PyTorch con capas lineales.</p>
<p>El Deep Learning impulsa muchas innovaciones recientes y emocionantes, tales como la <em>traducción de idiomas</em>, <em>coches autónomos</em>, <em>diagnósticos médicos y chatbots.</em></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="600"></p>
</figure>
</div>
<section id="qué-es-deep-learning" class="level2">
<h2 class="anchored" data-anchor-id="qué-es-deep-learning">Qué es Deep Learning?</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<p>Deep Learning (aprendizaje profundo) es un subconjunto del aprendizaje automático (machine learning). La estructura del modelo es una red de entradas (input), capas ocultas (hidden layers) y salidas (output), como se muestra en la siguiente imagen:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig3.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<p>Como apreciamos en la figura, una red puede tener una o muchas capas ocultas</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig4.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="250"></p>
</figure>
</div>
<p>La intuición original detrás del aprendizaje profundo era crear modelos inspirados en el cerebro humano, sobre todo por cómo aprende el cerebro humano: a través de células interconectadas llamadas neuronas. Es por esto que llamamos a los modelos de aprendizaje profundo <strong><code>Redes Neuronales</code></strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig5.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="150"></p>
</figure>
</div>
<p>Estas estructuras de modelos en capas requieren muchos más datos en comparación con otros modelos de aprendizaje automático para derivar patrones. Generalmente hablamos de al menos cientos de miles de puntos de datos.</p>
</section>
<section id="pytorch-un-framework-del-deep-learning" class="level2">
<h2 class="anchored" data-anchor-id="pytorch-un-framework-del-deep-learning">PyTorch: un framework del deep learning</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig6.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="180"></p>
</figure>
</div>
<p>Si bien existen varios framework y paquetes para implementar el aprendizaje profundo en cuanto a algoritmos, nos centraremos en PyTorch, uno de los frameworks más populares y mejor mantenidos. <em>PyTorch fue desarrollado originalmente por Meta IA como parte del laboratorio de investigación de inteligencia artificial de Facebook antes de que pasara a depender de la fundación Linux.</em></p>
<p>Está diseñado para ser intuitivo y fácil de usar, compartiendo muchas similitudes con la biblioteca de Python NumPy.</p>
<section id="pytorch-tensors" class="level4">
<h4 class="anchored" data-anchor-id="pytorch-tensors">PyTorch Tensors</h4>
<p>Podemos importar el módulo PyTorch llamando a</p>
<div id="4c430d2f" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><p>La estructura de datos fundamental en PyTorch es un tensor, que es similar a una matriz.</p></li>
<li><p>Puede soportar muchas operaciones matemáticas y constituye un componente básico para nuestras redes neuronales.</p></li>
<li><p>Se pueden crear tensores a partir de listas de Python o matrices NumPy utilizando la clase <code>torch.tensor()</code> esta clase convierte los datos a un formato compatible para el aprendizaje profundo.</p></li>
</ul>
<div id="592847f7" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>mi_lista <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>], [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>tensor <span class="op">=</span> torch.tensor(mi_lista)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tensor)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[1, 2, 3],
        [4, 5, 6]])</code></pre>
</div>
</div>
</section>
<section id="atributos-de-los-tensores" class="level3">
<h3 class="anchored" data-anchor-id="atributos-de-los-tensores">Atributos de los Tensores</h3>
<p>Podemos llamar a <code>tensor.shape</code> para mostrar la forma de nuestro objeto recién creado.</p>
<div id="80ce1998" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tensor.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([2, 3])</code></pre>
</div>
</div>
<p>Y <code>tensor.dtype()</code> para mostrar su tipo de datos, aquí un entero de 64 bits.</p>
<div id="01470cd4" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tensor.dtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>torch.int64</code></pre>
</div>
</div>
<p>Verificar la forma y el tipo de datos garantiza que los tensores se alineen correctamente con nuestro modelo y tarea, y puede ayudarnos en caso de depuración.</p>
<section id="operaciones-con-tensores" class="level4">
<h4 class="anchored" data-anchor-id="operaciones-con-tensores">Operaciones con Tensores</h4>
<p>Se pueden sumar o restar tensores de PyTorch, siempre que sus formas sean compatibles.</p>
<div id="b00e6aae" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> torch.tensor([[<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">2</span>,<span class="dv">2</span>]])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> torch.tensor([[<span class="dv">2</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">3</span>]])</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> torch.tensor([[<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>], [<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">5</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="edb8d1da" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a <span class="op">+</span> b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[3, 3],
        [5, 5]])</code></pre>
</div>
</div>
<p>Cuando las dimensiones no son compatibles, obtendremos un error.</p>
<p>También podemos realizar la multiplicación por elemento, lo que implica multiplicar cada elemento correspondiente.</p>
<div id="328f4d98" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a<span class="op">*</span>b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[2, 2],
        [6, 6]])</code></pre>
</div>
</div>
<p>También esta incluida la multiplicación de matrices, que no es más que uno forma de combinar dos matrices para crear una nueva.</p>
<div id="e4552652" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a <span class="op">@</span> b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[ 5,  5],
        [10, 10]])</code></pre>
</div>
</div>
<p>Detras de escena, los modelos de aprendizaje profundo realizan innumerables operaciones como la suma y multiplicación para procesar datos y aprender patrones.</p>
</section>
</section>
</section>
<section id="redes-neuronales-y-capas" class="level2">
<h2 class="anchored" data-anchor-id="redes-neuronales-y-capas">Redes Neuronales y Capas</h2>
<p>Vamos a contruir nuestra primer red neuronal usando tensores de PyTorch.</p>
<p>Una red neuronal consta de capas de entrada, ocultas y de salida.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig7.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<p>La <strong>capa de entrada</strong> contiene las características del conjunto de datos,</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig8.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<p>La <strong>capa de salida</strong> contiene las predicciones,</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig9.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<p>Y hay <strong>capas ocultas (hidden layers)</strong> en el medio</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig10.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<p>Si bien una red puede tener cualquier cantidad de capas ocultas, comenzaremos construyendo una red sin capas ocultas donde la capa de salida es una capa lineal.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig11.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<ul>
<li><p>Aquí, cada neurona de entrada se conecta a cada neurona de salida, lo que se denomina una red “totalmente conectada”.</p></li>
<li><p>Esta red es equivalente a un modelo lineal y nos ayuda a comprender los fundamentos antes de agregar complejidad.</p></li>
</ul>
<p>Usaremos el módulo <code>torch.nn</code> para construir nuestras redes. Esto hace que el código de la red sea más conciso y flexible y se importa convencionalmente como <code>nn</code>.</p>
<div id="8da881d8" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al diseñar una red neuronal, las dimensiones de las capas de entrada y salida están predefinidas.</p>
<ul>
<li><p>La cantidad de neuronas en la capa de entrada es la cantidad de características en nuestro conjunto de datos.</p></li>
<li><p>Y el número de neuronas en la capa de salida es el número de clases que queremos predecir.</p></li>
</ul>
<p>Digamos que creamos un input_tensor con forma de <span class="math inline">\(1\times 3\)</span>.</p>
<div id="4ad14aa0" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>input_tensor <span class="op">=</span> torch.tensor(</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  [[<span class="fl">0.3471</span>, <span class="fl">0.4547</span>, <span class="op">-</span><span class="fl">0.2356</span>]]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos pensar en esto como una fila con tres <em>“carectísticas”</em> o <em>“neuronas”</em> .</p>
<p>A continuación, pasamos este input_tensor a una capa lineal, que aplica una función lineal para realizar predicciones.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig12.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="100"></p>
</figure>
</div>
<p>Para ello usaremos <code>nn.Linear()</code> toma dos argumentos: <code>int_features</code> es el número de características en nuestra entrada ( en este caso, tres) y <code>out_features</code> es el tamaño del tensor de salida (en este caso, dos).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig13.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="100"></p>
</figure>
</div>
<div id="79cd1af2" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>linear_layer <span class="op">=</span> nn.Linear(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  in_features <span class="op">=</span> <span class="dv">3</span>,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  out_features <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Especificar correctamente <code>in_features</code> garantiza que nuestra capa lineal pueda recibir el input_tensor.</p>
<p>Por último, pasamos input_tensor a linear_layer para generar una salida.</p>
<div id="4d3e7c7e" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> linear_layer(input_tensor)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[-0.2560,  0.5373]], grad_fn=&lt;AddmmBackward0&gt;)</code></pre>
</div>
</div>
<p>Tenga en cuenta que esta salida tiene dos características o neuronas debido a las <code>out_features</code> especificadas en nuestra capa lineal.</p>
<p>Cuando input_tensor se pasa a linear_layer, se realiza una operación lineal para incluir pesos y sesgos.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig14.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="500"></p>
</figure>
</div>
</section>
<section id="pesos-weights-y-sesgos-biases" class="level2">
<h2 class="anchored" data-anchor-id="pesos-weights-y-sesgos-biases">Pesos (weights) y Sesgos (biases)</h2>
<p>Cada capa lineal tiene un conjunto de pesos y sesgos asociados. Estas son las cantidades clave que definen una neurona.</p>
<div id="0c1d02db" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(linear_layer.weight)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Parameter containing:
tensor([[ 0.4779,  0.3367,  0.3743],
        [-0.4978,  0.4398,  0.2074]], requires_grad=True)</code></pre>
</div>
</div>
<div id="a59bd438" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(linear_layer.bias)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Parameter containing:
tensor([-0.4867,  0.5590], requires_grad=True)</code></pre>
</div>
</div>
<ul>
<li><p>Los pesos reflejan la importancia de diferentes características.</p></li>
<li><p>El sesgos es un término adicional que es independiente de los pesos, y proporciona a las neurona una salida de referencia.</p></li>
</ul>
<p>Al principio, la capa lineal asigna pesos y sesgos aleatorios; estos se ajustan posteriormente.</p>
<p>Imaginemos nuestra red totalmente conectada en acción.</p>
<p>Digamos que tenemos un conjunto de datos meteorológicos con tres características: <em>temperatura (temperature), humedad (humidity) y viento (wind).</em> Y queremos predecir si <em>lloverá (rain) o estará nublado (cloudy).</em></p>
<ol type="1">
<li><p>La característica humeda tendrá un peso más significativo en comparación a las demás características, ya que es un fuerte predictor de lluvia y nubes.</p></li>
<li><p>Los datos meteorológicos corresponden a una región tropical con alta probabilidad de lluvia, por lo que agrega un sesgo para tener en cuenta esta información de referencia.</p></li>
</ol>
<p>Con esta información, nuestro modelo hace una predicción.</p>
</section>
<section id="capaz-y-parámetros-ocultos" class="level2">
<h2 class="anchored" data-anchor-id="capaz-y-parámetros-ocultos">Capaz y Parámetros Ocultos</h2>
<p>Hasta ahora, hemos utilizado una capa de entrada y una capa de lineal. Ahora, agregaremos más capas para ayudar a la red a aprender patrones complejos.</p>
<section id="apilamiento-de-capaz-con-nn.sequential" class="level3">
<h3 class="anchored" data-anchor-id="apilamiento-de-capaz-con-nn.sequential">Apilamiento de capaz con nn.Sequential()</h3>
<p>Apilaremos tres capas lineales usando <code>nn.Sequential()</code>, un contenedor de PyTorch para apilar capas en secuencia. Esta red toma la entrada, la pasa a cada capa lineal en secuencia y devuelve la salida.</p>
<pre class="{bash}"><code>model = nn.Sequential(
  nn.Linear(n_features, 8),
  nn.Linear(8, 4),
  nn.Linear(4, n_classes)
)</code></pre>
<ul>
<li><p>En este caso, las capas dentro de <code>nn.Sequential()</code> son capas ocultas.</p></li>
<li><p><code>n_features</code> representa el número de características de entrada y <code>n_classes</code> representa el número de clases de salida, ambas definidas por el conjunto de datos.</p></li>
</ul>
</section>
<section id="adición-de-capas" class="level3">
<h3 class="anchored" data-anchor-id="adición-de-capas">Adición de capas</h3>
<p>Podemos añadir tantas capas ocultas como queramos.</p>
<p><img src="img/fig17.png" class="img-fluid" width="450"></p>
<p>La dimensión de cada capa coincide con la dimensión de salida de la anterior.</p>
<div id="1866165d" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">10</span>, <span class="dv">18</span>),</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">18</span>, <span class="dv">20</span>),</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">20</span>, <span class="dv">5</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En nuestro ejemplo de tres capas, la primera capa toma 10 características y genera 18. La segunda toda 18 y genera 20. Finalmente, la tercera toma 20 y genera 5.</p>
</section>
<section id="las-capas-están-hechas-de-neuronas" class="level3">
<h3 class="anchored" data-anchor-id="las-capas-están-hechas-de-neuronas">Las capas están hechas de neuronas</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig18.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="200"></p>
</figure>
</div>
<p>Una capa está completamente conectada cuando cada neurona se vincula a todas las neuronas de la capa anterior, como se muestra en rojo en la figura.</p>
<p>Cada neurona es una capa lineal:</p>
<ul>
<li><p>realiza una operación lineal utilizando todas las neuonras de la capa anterior.</p></li>
<li><p>Por tanto, una sola neurona tiene <span class="math inline">\(N+1\)</span> parámetros que se puede aprender, siendo la dimensión de salida la capa anterior, más 1 para el sesgo.</p></li>
</ul>
</section>
<section id="parámetros-y-capacidad-del-modelo" class="level3">
<h3 class="anchored" data-anchor-id="parámetros-y-capacidad-del-modelo">Parámetros y Capacidad del Modelo</h3>
<p>Aumetar el número de capas ocultas aumenta el número total de parámetros en el modelo, también conocido como capacidad del modelo. Los modelos de mayor capacidad pueden manejar conjuntos de datos más complejos, pero su entrenamiento puede llevar más tiempo.</p>
<p>Una forma eficaz de evaluar la capacidad de un modelo es calcular su número total de parámetros.</p>
<p>Vamos a desglosarlo con una red de dos capas,</p>
<div id="e68d09cb" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">8</span>, <span class="dv">4</span>),</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">4</span>, <span class="dv">2</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><p><strong>La primera capa</strong> tiene 4 neuronas, cada neurona tiene 8 pesos y un sesgo, lo que da como resultado 36 parámetros.</p></li>
<li><p>La segunda capa tiene 2 neuronas, cada neurona tiene 4 pesos y un sesgo, para un total de 10 parámetros.</p></li>
<li><p>Sumándolos todos, este modelo tiene 46 parámetros que se pueden aprender en total</p></li>
</ul>
<p>También podemos calcular esto en PyTorch usando el método <code>.numel()</code>. Este método devuelve el número de elementos de un tensor.</p>
<div id="93c4d66a" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> parameter <span class="kw">in</span> model.parameters():</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  total <span class="op">+=</span> parameter.numel()</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>46</code></pre>
</div>
</div>
</section>
<section id="balance-entre-complejidad-y-eficiencia" class="level3">
<h3 class="anchored" data-anchor-id="balance-entre-complejidad-y-eficiencia">Balance entre complejidad y eficiencia</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig19.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></p>
</figure>
</div>
<p>Comprender el recuento de parámetros nos ayuda a equilibrar la complejidad y la eficiencia del modelo. Demasiados parámetros pueden dar lugar a tiempos de entrenamiento largos o sobreajuste, mientras que muy pocos pueden limitar la capacidad de aprendizaje.</p>
</section>
</section>
</section>
<section id="hiperparámetros-y-arquitectura-de-redes-neuronales" class="level1">
<h1>Hiperparámetros y arquitectura de redes neuronales</h1>
<p>Para entrenar una red neuronal en PyTorch, primero tendremos que entender componentes adicionales, como las funciones de activación y pérdida. Entonces nos daremos cuenta de que entrenar una red requiere reducir mínimo esa función de pérdida, lo que se hace calculando gradientes. Aprenderemos a utilizar estos gradientes para actualizar los parámetros de tu modelo.</p>
<section id="funciones-de-activación" class="level2">
<h2 class="anchored" data-anchor-id="funciones-de-activación">Funciones de Activación</h2>
<p>Hasta ahora hemos visto redes neuronales formadas únicamente por capas lineales.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig20.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="250"></p>
</figure>
</div>
<p>Podemos agregar <strong>no linealidad</strong> a nuestros modelos usando funciones de activación. Discutiremos dos funciones de activación:</p>
<ul>
<li><p><strong>Sigmoid</strong> para clasificación binaria y,</p></li>
<li><p><strong>Softmax</strong> para clasificación multiclase.</p></li>
</ul>
<p>Esta no linealidad permite que las redes aprendan cosas más complejas, interacciones entre entradas y objetivos que son relaciones <strong>no linealeales.</strong></p>
<p>Llamaremos a la salida de la última capa lineal la <strong>“pre-activación”.</strong> Salida, que pasaremos a funciones de activación para obtener la salida transformada.</p>
<section id="función-sigmoid" class="level3">
<h3 class="anchored" data-anchor-id="función-sigmoid">Función Sigmoid</h3>
<p>La función de activación sigmoidea se utiliza ampliamente para problemas de clasificación binaria. Digamos que estamos tratando de clasificar un animal como mamífero o no?. Tenemos tres datos: el número de extremidades, si pone huevos y si tiene pelo. Las dos últimas son variables binarias: 1 si es si, 0 si no.</p>
<p><img src="img/fig21.png" class="img-fluid" width="700"></p>
<p>Pasar la entrada a un modelo con dos capas lineales devuelve una única salida: el número 6, tal como apreciamos en la siguiente figura:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig22.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="700"></p>
</figure>
</div>
<p>Este número aún no es interpretable. <strong>Tenemos que pasar el número 6 por la función sigmoide</strong>, transformandolo en un rango que represente la probabilidad entre cero y uno.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig23.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="700"></p>
</figure>
</div>
<p>Si el resultado está más cerca de uno (mayor que 0.5), lo etiquetamos como clase uno (mamífero). Si fuese menor que 0.5 la predección sería cero (no un mamifero).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig24.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="700"></p>
</figure>
</div>
<p>Ahora, implementemos sigmoide en PyTorch.</p>
<div id="82e8f454" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>input_tensor <span class="op">=</span> torch.tensor([[<span class="dv">6</span>]])</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>sigmoid <span class="op">=</span> nn.Sigmoid()</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> sigmoid(input_tensor)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.9975]])</code></pre>
</div>
</div>
<p>Normalmente, <code>nn.Sigmoid()</code> se agrega como el último paso en <code>nn.Sequential()</code>, transformando automáticamente la salida de la capa lineal final.</p>
<div id="683c7dd2" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">6</span>, <span class="dv">4</span>), <span class="co"># Primera capa lineal </span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">4</span>, <span class="dv">1</span>), <span class="co"># Segunda capa lineal</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  nn.Sigmoid()     <span class="co"># Función de activación</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Curiosamente, una red neuronal con solo capas lineales y una activación sigmoidea se comporta como una <strong>Regresión Logística.</strong> Más adelante agregaremos más capas y activaciones para comprender realmente el verdadero potencial del Deep Learning.</p>
</section>
<section id="función-softmax" class="level3">
<h3 class="anchored" data-anchor-id="función-softmax">Función Softmax</h3>
<p>Usamos softmax, otra función de activación popular, para clasificación multiclase que implica más de dos etiquetas de clase.</p>
<p>Digamos que tenemos tres clases:</p>
<ol type="1">
<li><p>Pajaro o Bird (0)</p></li>
<li><p>Mamífero o Mammal (1)</p></li>
<li><p>Reptil o Reptile (2)</p></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig25.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></p>
</figure>
</div>
<p>En esta red, Softmax toma una dimensión tridimensional, salida de preactivación y genera una salida de la misma forma, una por tres.</p>
<p>La salida es una distribución de probabilidad:</p>
<ul>
<li><p>Por cada elemento está entre cero y uno, y</p></li>
<li><p>los valores suman uno.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig26.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="350"></p>
</figure>
</div>
<p>Aquí, la predicción es para la segunda clase, mamíferos, que tiene la probabilidad más alta 0.842.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig27.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="350"></p>
</figure>
</div>
<p>En PyTorch, usamos <code>nn.Softmax()</code></p>
<div id="d288e88b" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>input_tensor <span class="op">=</span> torch.tensor(</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  [[<span class="fl">4.3</span>, <span class="fl">6.1</span>, <span class="fl">2.3</span>]]</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>probabilities <span class="op">=</span> nn.Softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co"># dim = -1 indica que softmax se aplica a la última dimensión de input_tensor</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>output_tensor <span class="op">=</span> probabilities(input_tensor)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output_tensor)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.1392, 0.8420, 0.0188]])</code></pre>
</div>
</div>
<p>Similar a sigmoide, softmax puede ser la última capa en nn.Sequential.<br>
</p>
</section>
</section>
<section id="paso-hacia-adelante" class="level2">
<h2 class="anchored" data-anchor-id="paso-hacia-adelante">Paso hacia adelante</h2>
<p>Hemos explorado tensores, redes pequeñas y funciones de activación. Ahora profundicemos en la generación de predicciones.</p>
<p>Este proceso se llama <strong>“ejecutar un paso hacia adelante”</strong> a través de una red.</p>
<section id="qué-es-una-paso-hacia-adelante-forward-pass" class="level3">
<h3 class="anchored" data-anchor-id="qué-es-una-paso-hacia-adelante-forward-pass">Qué es una paso hacia adelante (Forward Pass)?</h3>
<p>Es cuando los datos de entrada fluyen a través de una red neuronal en dirección hacia adelante, para producir resultados o predicciones, pasa a través de cada capa de red.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig28.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="350"></p>
</figure>
</div>
<p>Los calculos transforman los datos en nuevas representaciones en cada capa, que pasa a la siguiente capa hasta que se produce el resultado final.</p>
<p>El propósito del paso hacia adelante es pasar datos de entrada a través de la red y producir predicciones o resultados basados en los parámetros aprendidos del modelo, también conocidos como pesos y sesgos.</p>
<p>Este proceso es esencial tanto para el entrenamiento como para realizar nuevas predicciones.</p>
<p>El resultado final puede ser clasificaciones binarias, clasificaciones multiclase o predicciones numéricas (regresiones).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig29.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></p>
</figure>
</div>
<p>Veremos un ejemplo de cada uno.</p>
<p>Digamos que tenemos datos de entrada de cinco animales, con seís características o neuronas por punto de datos.</p>
<div id="a96a6b0a" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> torch.tensor(</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  [[<span class="op">-</span><span class="fl">0.4421</span>, <span class="fl">1.5207</span>, <span class="fl">2.0607</span>, <span class="op">-</span><span class="fl">0.3647</span>, <span class="fl">0.4691</span>, <span class="fl">0.0946</span>],</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  [<span class="op">-</span><span class="fl">0.9155</span>, <span class="op">-</span><span class="fl">0.0475</span>, <span class="op">-</span><span class="fl">1.3645</span>, <span class="op">-</span><span class="fl">0.6336</span>, <span class="op">-</span><span class="fl">1.9520</span>, <span class="op">-</span><span class="fl">0.3398</span>],</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  [<span class="fl">0.7406</span>, <span class="fl">1.6763</span>, <span class="op">-</span><span class="fl">0.8511</span>, <span class="fl">0.2432</span>, <span class="fl">0.1123</span>, <span class="op">-</span><span class="fl">0.0633</span>],</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  [<span class="op">-</span><span class="fl">1.6630</span>, <span class="op">-</span><span class="fl">0.0718</span>, <span class="op">-</span><span class="fl">0.1285</span>, <span class="fl">0.5396</span>, <span class="op">-</span><span class="fl">0.0288</span>, <span class="op">-</span><span class="fl">0.8622</span>],</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  [<span class="op">-</span><span class="fl">0.7413</span>, <span class="fl">1.7920</span>, <span class="op">-</span><span class="fl">0.0883</span>, <span class="op">-</span><span class="fl">0.6685</span>, <span class="fl">0.4745</span>, <span class="op">-</span><span class="fl">0.4245</span>]]</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Creamos una pequeña red con dos capas lineales y una función de activación sigmoidea en secuencia.</p>
<div id="5df0d654" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">6</span>, <span class="dv">4</span>),</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">4</span>, <span class="dv">1</span>),</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  nn.Sigmoid()</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><p>La primera capa toma seis características como entrada, genera cuatro.</p></li>
<li><p>La segunda capa procesa esto para obtener una probailidad final.</p></li>
</ul>
<p>El resultado de nuestra clasificación binaria es una única probabilidad entre cero y uno para cada uno de nuestros cinco animales.</p>
<div id="93297be1" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> model(input_data)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.6029],
        [0.6443],
        [0.4530],
        [0.6021],
        [0.5374]], grad_fn=&lt;SigmoidBackward0&gt;)</code></pre>
</div>
</div>
<p>Recuerde que comúnmente utilizamos un umbral de 0.5 para convertirlos en etiquetaas de 0 y 1, es decir:</p>
<ul>
<li><p>Class = 1 para <span class="math inline">\(output \geq 0.5\)</span></p></li>
<li><p>Class = 0 para <span class="math inline">\(output \leq 0.5\)</span></p></li>
</ul>
<p>Esta salida no será significativa hasta que usemos retropropagación para actualizar los pesos y sesgos de las capas. Hablaremos más sobre esto más adelante.</p>
</section>
<section id="clasificación-multi-class-forward-pass" class="level3">
<h3 class="anchored" data-anchor-id="clasificación-multi-class-forward-pass">Clasificación Multi-Class: Forward Pass</h3>
<p>El modelo sería similar si quisiéramos ejecutar una clasificación de múltiples clases.</p>
<p>Digamos que estamos prediciendo tres clases: <em>mamíferos (Class 1), aves (Class 2) o reptiles (Class 3).</em></p>
<p>Específicamos que nuestro modelo tiene tres clases, estableciendo este valor como la dimensión de salida de la última capa lineal.</p>
<div id="c3a632e4" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>n_classes <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">6</span>, <span class="dv">4</span>),</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">4</span>, n_classes),</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  nn.Softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Usamos Softmax en lugar de Sigmoid, con <span class="math inline">\(dim = -1\)</span> para indicar los 5 animales. Los anímales tiene la misma última dimensión que la salida de la última capa lineal.</p>
<div id="9019ccbe" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> model(input_data)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([5, 3])</code></pre>
</div>
</div>
<p>Utilizando la misma entrada que antes, la forma de salida es <span class="math inline">\(5\times 3\)</span>.</p>
<div id="205d6023" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.3668, 0.3895, 0.2438],
        [0.3165, 0.1723, 0.5112],
        [0.3006, 0.3020, 0.3974],
        [0.3483, 0.3040, 0.3477],
        [0.2686, 0.2752, 0.4562]], grad_fn=&lt;SoftmaxBackward0&gt;)</code></pre>
</div>
</div>
<p>Note que cuando imprimimos la salida, cada fila representa las probabilidades de tres clases, que suman uno. La etiqueta prevista para cada fila se asigna a la clase con la mayor probabilidad.</p>
<p>En nuestro ejemplo, todas las filas son mamíferos.</p>
</section>
<section id="regresión-forward-pass" class="level3">
<h3 class="anchored" data-anchor-id="regresión-forward-pass">Regresión: Forward Pass</h3>
<p>El último modelo que analizaremos es la regresión: predecir valores numéricos continuos.</p>
<p>Ahora usaremos las mismos datos para predecir el peso de los animales en función de sus propiedades.</p>
<div id="34da26b0" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">6</span>, <span class="dv">4</span>), </span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  nn.Linear(<span class="dv">4</span>, <span class="dv">1</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> model(input_data)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[-0.6805],
        [ 0.1887],
        [-0.2363],
        [ 0.0359],
        [-0.3907]], grad_fn=&lt;AddmmBackward0&gt;)</code></pre>
</div>
</div>
<p>Esta vez no hay función de activación al final, y la última dimensión de la última capa lineal devuelve una salida con una característica.</p>
<p>Las dimensiones de salida son <span class="math inline">\(5\times 1\)</span>: cinco valores continuos, uno para cada fila.</p>
</section>
</section>
<section id="funciones-de-pérdida-para-evaluar-las-predicciones-del-modelo" class="level2">
<h2 class="anchored" data-anchor-id="funciones-de-pérdida-para-evaluar-las-predicciones-del-modelo">Funciones de Pérdida para Evaluar las Predicciones del Modelo</h2>
<p>Hemos generado predicciones ejecutando un paso hacia adelante, el siguiente paso es ver qué tan buenas son nuestras predicciones en comparación con los valores reales.</p>
<section id="función-de-pérdida" class="level4">
<h4 class="anchored" data-anchor-id="función-de-pérdida">Función de pérdida</h4>
<p>La función de pérdida, otro componente de las redes neuronales, nos dicen qué tan bueno es nuestro modelo para hacer predicciones durante el entrenamiento.</p>
<p>Toma una predicción del modelo <span class="math inline">\((\hat{y})\)</span> y una etiqueta verdadera <span class="math inline">\(y\)</span>, o dato real, y genera un dato flotante, tal como se puede apreciar en el siguiente esquema</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig30.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="800"></p>
</figure>
</div>
<p>Utilicemos nuestra multiclase</p>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 13%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 13%">
<col style="width: 12%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th>Hair</th>
<th>Feathers</th>
<th>Eggs</th>
<th>Milk</th>
<th>Fins</th>
<th>Legs</th>
<th>Tail</th>
<th>Domestic</th>
<th>Catsize</th>
<th>Class</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>modelo de clasificación que predice si un animal es un mamífero (0), ave (1) o reptil (2).</p>
<ul>
<li><p>Si nuestro modelo predice que la clase es igual a cero, es correcto y el valor de la pérdida será bajo.</p></li>
<li><p>Una predicción incorrecta haría que el valor de la pérdida fuera alto.</p></li>
<li><p>Nuestro objetivo es minimizar las pérdidas.</p></li>
</ul>
</section>
<section id="calculo-de-la-pérdida" class="level4">
<h4 class="anchored" data-anchor-id="calculo-de-la-pérdida">Calculo de la pérdida</h4>
<p>La pérdida se calcula utilizando una función de pérdida, <span class="math inline">\(F\)</span>, que toma el dato real y el predicho, es decir,</p>
<p><span class="math display">\[
Loss = F(y, \hat{y})
\]</span></p>
<ul>
<li><p>En nuestro ejemplo de los animales, los valores posibles para nuestra verdadera clase de <span class="math inline">\(y\)</span> son los n<u>úmeros enteros 0, 1 o 2, es decir,</u> <span class="math inline">\(y \in \{0, 1 , 2\}\)</span>.</p></li>
<li><p><span class="math inline">\(\hat{y}\)</span> es un tensor con las mismas dimensiones que el número de clases <span class="math inline">\(N\)</span>, es decir, <span class="math inline">\(\hat{y}\in \{-5.2, 4.6, 0.8\}\)</span>. Si <span class="math inline">\(N=3\)</span> entonces la salidad softmax es un tensor de forma <span class="math inline">\(1\times 3\)</span>.</p></li>
</ul>
</section>
<section id="codificación-one-hot" class="level4">
<h4 class="anchored" data-anchor-id="codificación-one-hot">Codificación one-hot</h4>
<p>Usamos codificación one-hot para convertir un entero <span class="math inline">\(y\)</span> en un tensor de ceros y unos para que podamos comparar para evaluar el rendimiento del modelo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig31.png" class="img-fluid figure-img" width="300"></p>
<figcaption>Figura 1</figcaption>
</figure>
</div>
<p>Por ejemplo, si <span class="math inline">\(y=0\)</span> con tres clases, la forma codificada es 1, 0, 0 como se aprecia en <strong>Figura 1.</strong></p>
<p>Podemos importar <code>torch.nn.functional</code> como <code>F</code> para evitar la codificación one-hot manual.</p>
<div id="104d1b47" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(F.one_hot(torch.tensor(<span class="dv">0</span>), num_classes <span class="op">=</span> <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([1, 0, 0])</code></pre>
</div>
</div>
<p>En el primer ejemplo, la verdad fundamental es cero (la primera clase). Tenemos 3 clases, por lo que la función genera un tensor de tres elementos con uno en la primera posición y ceros en el resto.</p>
<div id="03fd9da0" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(F.one_hot(torch.tensor(<span class="dv">1</span>), num_classes <span class="op">=</span> <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0, 1, 0])</code></pre>
</div>
</div>
<p>Notemos ahora que si <span class="math inline">\(y=1\)</span> (la segunda clase), el tensor de salida tiene un uno en la segunda posición y ceros en caso contrario.</p>
<div id="52fe6374" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(F.one_hot(torch.tensor(<span class="dv">2</span>), num_classes <span class="op">=</span> <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0, 0, 1])</code></pre>
</div>
</div>
<p>Por último, si <span class="math inline">\(y=2\)</span> (tercera clase), el tensor de salida tiene un uno en la última posición y ceros en el resto de los casos.</p>
</section>
<section id="función-de-pérdida-cross-entropy-en-pytorch" class="level3">
<h3 class="anchored" data-anchor-id="función-de-pérdida-cross-entropy-en-pytorch">Función de Pérdida Cross Entropy en PyTorch</h3>
<p>Una vez completada la codificación, podemos pasarla junto con nuestras predicciones a una función de pérdida. Lo que almacenaríamos será el tensor de <em>“puntuaciones”</em>.</p>
<div id="d266a427" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.nn <span class="im">import</span> CrossEntropyLoss</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> torch.tensor([<span class="op">-</span><span class="fl">5.2</span>, <span class="fl">4.6</span>, <span class="fl">0.8</span>])</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>one_hot_target <span class="op">=</span> torch.tensor([<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función de pérdida más comunmente utilizada para la clasificaci´øn es la pérdida de entropía cruzada.</p>
<p>Comencemos definiendo nuestra función de pérdida como <em>“criterio”.</em> Luego le pasamos el método <code>.double()</code> del tensor de puntuaciones y del tensor <code>one_hot_target.</code></p>
<div id="12f91bd6" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>criterion <span class="op">=</span> CrossEntropyLoss()</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(criterion(scores.double(), one_hot_target.double()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor(9.8222, dtype=torch.float64)</code></pre>
</div>
</div>
<p>Esto garantiza que los tensores estén en el formato correcto para la función de pérdida. La salida es el valor de pérdida calculado.</p>
<p>En resumen, la función de pérdida toma como entrada el tensor de puntuaciones, que es el modelo, predice antes de la función softmax final y la etiqueta de verdad codificada one-hot. Emite un único flotante, la pérdida de esa muestra.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig32.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="550"></p>
</figure>
</div>
<p>Recordemos que nuestro objetivo es minimizar esa pérdida.</p>
</section>
</section>
<section id="utilizar-derivadas-para-actualizar-los-parámetros-del-modelo" class="level2">
<h2 class="anchored" data-anchor-id="utilizar-derivadas-para-actualizar-los-parámetros-del-modelo">Utilizar derivadas para Actualizar los Parámetros del Modelo</h2>
<p>Veamos ahora cómo podemos minímizar la pérdida. Sabemos que un modelo predice mal cuando la pérdida es alta. Podemos utilizar derivadas o gradientes para minimizar esta pérdida.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig33.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="300"></p>
</figure>
</div>
<p>Imaginemos la función de pérdida como un valle. La derivada representa la pendiente, es decir qué tan pronunciada sube o baja la curva.</p>
<ul>
<li><p>Las pendientes pronunciadas, mostradas con flechas rojas, indican derivadas altas y pesos grandes.</p></li>
<li><p>Las pendientes más suaves, representadas por flechas verdes, tienen derivadas pequeñas y pesos más pequeños.</p></li>
<li><p>En el fondo del valle, mostrado por la flecha azul, la pendiente es plana y la derivada es cero. <strong>Este punto es el mínimo de la función de pérdida que pretendemos alcanzar.</strong></p></li>
</ul>
<section id="funciones-convexas-y-no-convexas" class="level3">
<h3 class="anchored" data-anchor-id="funciones-convexas-y-no-convexas">Funciones Convexas y No-Convexas</h3>
<p>Las funciones convexas tienen un mínimo global.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig34.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>Las funciones no convexas, como las funciones de pérdida, tienen múltiples mínimos locales, donde el valor es inferior al de los puntos cercanos pero no el más bajo en general.</p>
<p>Al minimizar las funciones de pérdida, nuestro objetivo es localizar el mínimo global cuando <span class="math inline">\(x\)</span> es aproximadamente uno.</p>
</section>
<section id="conexión-de-derivadas-y-entrenamiento-de-modelos" class="level3">
<h3 class="anchored" data-anchor-id="conexión-de-derivadas-y-entrenamiento-de-modelos">Conexión de derivadas y entrenamiento de modelos</h3>
<p>Durante el entrenamiento, ejecutamos un <strong><em>paso hacia adelante</em></strong> en las características y calculamos la pérdida comparando las predicciones con el valor objetivo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig38.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="500"></p>
</figure>
</div>
<p>Recuerde que los <strong><em>pesos</em></strong> y <strong><em>sesgos</em></strong> de las capas se inicializan aleatoriamente cuando se crea un modelo. Los actualizamos durante el entrenamiento mediante un <strong><em>paso hacia atrás</em></strong> o <strong><em>retropropogación.</em></strong></p>
<p>En el Deep Learning, <strong>las derivadas se conocen como gradientes.</strong></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig39.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="600"></p>
</figure>
</div>
<p>Calculamos los gradientes de la función de pérdida y los usamos para actualizar los parámetros del modelo. Incluyendo pesos y sesgos, con retropropagación, repitiendo hasta que las capas esten sintonizadas.</p>
</section>
<section id="backpropagation-retropropagación" class="level3">
<h3 class="anchored" data-anchor-id="backpropagation-retropropagación">Backpropagation (Retropropagación)</h3>
<p>Durante la retropropagación, si consideramos una red de tres capas lineales:</p>
<ul>
<li><p>podemos calcular gradientes de pérdida locales con respecto a <span class="math inline">\(L_2\)</span></p></li>
<li><p>Usamos <span class="math inline">\(L_2\)</span> para calcular el gradiente <span class="math inline">\(L_1\)</span></p></li>
<li><p>Y repetimos hasta llegar a la capa inicial <span class="math inline">\(L_0\)</span>.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig40.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="300"></p>
</figure>
</div>
<p>Veamos esto con PyTorch:</p>
<pre class="{bash}"><code>model = nn.Sequential(nn.Linear(16, 8),
nn.Linear(8, 4),
nn.Linear(4, 2))
prediction = model(sample)

criterion = CrossEntropyLoss()
loss = criterion(prediction, target)
loss.backward</code></pre>
<p>Después de ejecutar un paso hacia adelante, definimos una función de pérdida, aquí <code>CrossEntropyLoss()</code> y úselo para comparar predicciones con valores objetivo.</p>
<p>Usando <code>.backward()</code>, calculamos gradientes basados en esta pérdida, que se almacenan en los atributos <code>.grad</code> de los pesos y <code>.bias</code> de los sesgos de cada capa.</p>
<pre class="{bash}"><code>model[0].weight.grad
model[0].bias.grad
model[1].weight.grad
model[1].bias.grad
model[2].weight.grad
model[2].bias.grad</code></pre>
<p>Cada capa del modelo se puede indexar comenzando desde cero para acceder a sus pesos, sesgos y gradientes.</p>
</section>
<section id="actualizar-manualmente-los-parámetros-del-modelo" class="level3">
<h3 class="anchored" data-anchor-id="actualizar-manualmente-los-parámetros-del-modelo">Actualizar Manualmente los Parámetros del Modelo</h3>
<p>Para actualizar manualmente los parámetros del modelo, accedemos al gradiente de cada capa.</p>
<pre class="{bash}"><code># Tasa de aprendizaje tipicamente pequeña
lr = 0.001

# updater the pesos
weight = model[0].weight
weight_grad = model[0].weight.grad

# update de sesgos 
bias = model[0].bias
bias_grad = model[0].bias.grad </code></pre>
<p>luego multiplicamos por la tasa de aprendizaje y restamos este producto del peso.</p>
<pre class="{bash}"><code>bias = bias - lr*bias_grad </code></pre>
<p>La tasa de aprendizaje es otro parámetros ajustable. Discutiremos esto y el ciclo de entranamiento más adelante en este documento.</p>
</section>
<section id="gradiente-descendente" class="level3">
<h3 class="anchored" data-anchor-id="gradiente-descendente">Gradiente Descendente</h3>
<ul>
<li><p>Utilizamos un mecanismo llamado <em>“gradiente desendiente”</em> para encontrar el mínimo global de las funciones de pérdida.</p></li>
<li><p>PyTorch simplifica esto con optimizadores, como el descenso de gradiente estocástico (SGD).</p></li>
</ul>
<div id="65aa2bbc" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Creamos el optimizador</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> optim.SGD(model.parameters(), lr <span class="op">=</span> <span class="fl">0.001</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><p>Usamos <code>optim</code> para instanciar <code>SGD.</code></p></li>
<li><p><code>.parameters()</code> devuelve un iterable de todos los parámetros del modelo, que pasamos al optimizador.</p></li>
<li><p>Aquí utilizamos una tasa de aprendizaje estándar, “lr”.</p></li>
</ul>
<p>El optimizador calcula automáticamente los gradientes y actualiza los parámetros del modelo con <code>.step()</code></p>
<div id="d64ec715" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>optimizer.step()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="entrenar-una-red-neuronal-con-pytorch" class="level1">
<h1>Entrenar una red neuronal con PyTorch</h1>
<p>Ahora que hemos visto los componentes clave de una red neuronal, entrenaremos una utilizando un bucle de entrenamiento. Exploraremos posibles problemas, como la fuga de gradiente, y aprenderemos estrategías para resolverlos, como funciones de activación alternativas y el análisis de la tasa de aprendizaje.</p>
<section id="inmmersión-profunda-en-la-carga-de-datos" class="level3">
<h3 class="anchored" data-anchor-id="inmmersión-profunda-en-la-carga-de-datos">Inmmersión profunda en la carga de datos</h3>
<p>El manejo eficiente de datos es clave para entrenar modelos de aprendizaje profundo (Deep Learnig)</p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 8%">
<col style="width: 14%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 14%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th>animal_name</th>
<th>hair</th>
<th>feathers</th>
<th>eggs</th>
<th>milk</th>
<th>predator</th>
<th>legs</th>
<th>tail</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sparrow</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>eagle</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>cat</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>dog</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>4</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>lizard</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Nuestros datos de clasificación de animales estan en un archivo csv y se pueden cargar utilizando <code>pd.read_csv()</code>.</p>
<div id="3a384303" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>animals <span class="op">=</span> pd.read_csv(<span class="st">'animal_dataset.csv'</span>, sep <span class="op">=</span> <span class="st">";"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Usaremos pelo, plumas, huevos, leche, depredador, patas y cola como características para predecir todo el tipo de animal.</p>
<ul>
<li><p>La columna <strong>animal_name</strong> no es necesaria ya que los nombres no determinan la clasificación.</p></li>
<li><p>Tenga en cuenta que la columna <strong>type</strong> tiene tres categorías: ave (0), mamífero (1) y reptil (2).</p></li>
</ul>
<div id="14545623" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> animals.iloc[:, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> features.to_numpy()</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0 1 1 0 0 2 1]
 [0 1 1 0 1 2 1]
 [1 0 0 1 1 4 1]
 [1 0 0 1 0 4 1]
 [0 0 1 0 1 4 1]]</code></pre>
</div>
</div>
<ul>
<li><p>Usaremos <code>.iloc</code> para seleccionar todas las columnas excepto la primera y la (animal_name) última (type), lo que nos dará nuestras características de entrada.</p></li>
<li><p>Estos se convierten en una matriz NumPy (X), para un manejo más sencillo con PyTorch.</p></li>
</ul>
<p>De manera similar, podemos extraer la última columna (type) y almacenarla como una matriz de nuestros valores objetivo, que representan las etiquetas de clase para cada animal, a esto lo llamaremos <strong>y</strong>.</p>
<div id="cc537bd8" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>target <span class="op">=</span> animals.iloc[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> target.to_numpy()</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0 0 1 1 2]</code></pre>
</div>
</div>
</section>
<section id="tensordataset" class="level3">
<h3 class="anchored" data-anchor-id="tensordataset">TensorDataset</h3>
<p>Usaremos TensorDataset para preparar datos para los modelos de PyTorch.</p>
<div id="9c2816e8" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch </span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> TensorDataset</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esto nos permite almacenar nuestras características (X) y etiquetas destino (y) como tensores, lo que hace que sean fáciles de administrar.</p>
<ol type="1">
<li><p>Convertimos <span class="math inline">\(X\)</span> e <span class="math inline">\(y\)</span> en tensores usando el método tensor de PyTorch y los pasamos a TensorDataset</p>
<div id="da258afe" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> TensorDataset(torch.tensor(X), torch.tensor(y))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></li>
<li><p>Para acceder a una muestra individual, utilizamos la indexación de corchetes.</p>
<div id="7941344e" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>input_sample, label_sample <span class="op">=</span> dataset[<span class="dv">0</span>]</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'input sample:'</span>, input_sample)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'input_sample:'</span>, label_sample)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>input sample: tensor([0, 1, 1, 0, 0, 2, 1])
input_sample: tensor(0)</code></pre>
</div>
</div>
<p><br>
<br>
</p></li>
</ol>
</section>
<section id="escribir-nuestro-primer-bucle-de-entrenamiento" class="level2">
<h2 class="anchored" data-anchor-id="escribir-nuestro-primer-bucle-de-entrenamiento">Escribir nuestro primer bucle de entrenamiento</h2>
<p>Ahora que ya tenemos los componentes principales para entrenar un modelo de aprendizaje profundo con PyTorch.</p>
<section id="entrenando-una-red-neuronal" class="level3">
<h3 class="anchored" data-anchor-id="entrenando-una-red-neuronal">Entrenando una Red Neuronal</h3>
<p>Una vez que creamos un modelo, elegimos una función de pérdida, definimos un conjunto de datos y configuramos un optimizador, estamos listos para entrenar. Esto implica recorrer el conjunto de datos, calcular la pérdida, calcular gradientes y actualizar los parámetros del modelo. Este proceso, es llamado <strong>bucle de entrenamiento</strong>, se repite varias veces.</p>
<p>Un bucle de entrenamiento permite una mayor flexibilidad y control, dándonos la opción de personalizar diferentes elementos.</p>
<p>Trabajaremos con un conjunto de datos de salarios de científicos de datos para ver esto en acción.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 21%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th>experience_level</th>
<th>employment_type</th>
<th>remote_ratio</th>
<th>company_size</th>
<th>salary_in_usd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>1</td>
<td>0.036</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1.0</td>
<td>2</td>
<td>0.133</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>0.0</td>
<td>1</td>
<td>0.234</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1.0</td>
<td>0</td>
<td>0.076</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>1.0</td>
<td>1</td>
<td>0.170</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Las características son categóricas y el objetivo es el salario en dólares (salary_in_usd), ya normalizado. Dado que el objetivo es un valor continuo, este es un problema de regresión.</p></li>
<li><p>Para la regresión, utilizaremos una capa lineal como salida final en lugar de softmax o sigomoide.</p></li>
<li><p>Además, aplicaremos una función de pérdida específica de regresión, ya que la entropía cruzada solo se utiliza para tareas de clasificación.</p></li>
</ul>
<section id="mean-squared-error-loss" class="level4">
<h4 class="anchored" data-anchor-id="mean-squared-error-loss">Mean Squared Error Loss</h4>
<p>Podemos utilizar la pérdida de error cuadrático medio (MSE) para problemas de regresión. La pérdida de MSE es la media de la diferencia al cuadrado entre predicciones y el dato real o verdad fundamental, como se muestra en esta implementación en Python:</p>
<div id="6b6c0b4c" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mean_squared_loss(prediction, target):</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.mean((prediction <span class="op">-</span> target)<span class="op">**</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En PyTorch, utilizamos la función <code>nn.MSELoss</code> como criterio.</p>
<pre class="{bash}"><code>criterion = nn.MSELoss()
loss = criterion(prediction, target)</code></pre>
<p>Tenga en cuenta que tanto las predicciones como los objetivos deben ser tensores flotantes.</p>
<p>Pongamos todo junto ahora, tenemos dos matrices NumPy, “características” y “objetivo”, que tienen nuestros datos y etiquetas.</p>
<div id="7a93e45d" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_csv(<span class="st">"salary_datascince.csv"</span>, sep <span class="op">=</span> <span class="st">";"</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">experience_level</th>
<th data-quarto-table-cell-role="th">employment_type</th>
<th data-quarto-table-cell-role="th">remote_ratio</th>
<th data-quarto-table-cell-role="th">company_size</th>
<th data-quarto-table-cell-role="th">salary_in_usd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>1</td>
<td>0.036</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>0</td>
<td>1.0</td>
<td>2</td>
<td>0.133</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>2</td>
<td>0</td>
<td>0.0</td>
<td>1</td>
<td>0.234</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>0</td>
<td>1.0</td>
<td>0</td>
<td>0.076</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>0</td>
<td>1.0</td>
<td>1</td>
<td>0.170</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="926d8512" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> data.iloc[:, :<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> features.to_numpy()</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.  0.  0.5 1. ]
 [1.  0.  1.  2. ]
 [2.  0.  0.  1. ]
 [1.  0.  1.  0. ]
 [2.  0.  1.  1. ]]</code></pre>
</div>
</div>
<div id="495c2b15" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>target <span class="op">=</span> data.iloc[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> target.to_numpy()</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.036 0.133 0.234 0.076 0.17 ]</code></pre>
</div>
</div>
<div id="5bd78cc1" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> TensorDataset, DataLoader</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> TensorDataset(torch.tensor(X),</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>torch.tensor(y))</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>dataloader <span class="op">=</span> DataLoader(dataset, batch_size <span class="op">=</span> <span class="dv">4</span>, shuffle <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora podemos cargar nuestro conjunto de datos en la clase <code>DataLoader()</code> para habilitar el procesamiento por lotes.</p>
<ul>
<li>Aquí utilizamos un tamaño de lote pequeño de cuatro, pero la selección del tamaño de lote es personalizable dependiendo del caso de uso.</li>
</ul>
<p>A continuación creamos nuestro modelo, este conjunto de datos tiene cuatro características de entrada y un destino (salida).</p>
<div id="9d8d56bc" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(nn.Linear(<span class="dv">4</span>, <span class="dv">2</span>), </span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>nn.Linear(<span class="dv">2</span>, <span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>No necesitaremos codificación one-hot ya que se trata de un problema de regresión.</p>
<p>Finalmente, creamos el criterio de pérdida MSE y el optimizador, con una taza de aprendizaje predeterminada para la mayoría de los problemas de deep learning.</p>
<div id="19544085" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>criterio <span class="op">=</span> nn.MSELoss()</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> optim.SGD(model.parameters(), lr <span class="op">=</span> <span class="fl">0.001</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora podemos recorrer el conjunto de datos varias veces:</p>
<ul>
<li>Recorrer todo el conjunto de datos una vez se denomina época y entrenamos en múltiples época, indicadas por num_epochs. Para cada época, recorremos el cargador de datos. Cada iteración del cargador de datos proporciona un lote de muestras, que vimos anteriormente. Antes del pase hacia adelante , establecemos los gradientes a cero usando <code>optimizer.zero_grad()</code>, porque el optimizador almacena gradientes de pasos anteriores de manera predeterminada, obtenemos características y objetivos de cada muestra del cargador de datos. Utilizamos las características para el paso hacia adelante del modelo y utilizamos el objetivo para el cálculo de la pérdida y finalmente, utilizamos el optimizador para actualizar los parámetros del modelo.</li>
</ul>
<pre class="{bash}"><code>for epoch in range(num_epochs):
  for data in dataloader: 
    optimizer.zero_grad()
    feature, target = data 
    pred = model(feature)
    loss = criterion(pred, target)
    loss.backward()
    optimizer.step()
    </code></pre>
</section>
</section>
</section>
<section id="funciones-de-activación-relu" class="level2">
<h2 class="anchored" data-anchor-id="funciones-de-activación-relu">Funciones de Activación ReLU</h2>
<p>Hemos visto como las funciones de activación introducen no linealidad para ayudar a las redes neuronales a aprender patrones complejos y hemos aprendido sobre los gradientes y su papel dentro del ciclo de entrenamiento.</p>
<p>A veces, las funciones de activación pueden reducir demasiado los gradientes, lo que hace que el entrenamiento sea ineficiente.</p>
<p>Hasta ahora hemos trabajado con dos funciones de activación: <strong>sigmoidea</strong> y <strong>softmax,</strong> que normalmente se utilizan en la capa final de un modelo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig41.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="900"></p>
</figure>
</div>
<section id="limitaciones-de-sigmoid-y-softmax" class="level3">
<h3 class="anchored" data-anchor-id="limitaciones-de-sigmoid-y-softmax">Limitaciones de Sigmoid y Softmax</h3>
<p>Comenzaremos por comprender algunas de las limitaciones de la función sigmoidea.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig42.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="300"></p>
</figure>
</div>
<ul>
<li><p>Las salidas de sigmoid están limitadas entre 0 y 1, lo que significa que para cualquier entrada, la salida siempre estará dentro de este rango.</p></li>
<li><p>Sigmoid podría usarse en cualquier punto de una red. Sin embargo, los gradientes de la sigmoide, que se muestran en naranja, son muy pequeños para valores grandes y pequeños de <span class="math inline">\(x\)</span>. Este fenómeno se llama saturación. Durante la retropropagación, esto se vuelve problemático porque cada gradiente depende del anterior. Cuando los gradientes son extremadamente pequeños, no logran actualizar los pesos de manera efectiva.</p></li>
<li><p>Este problema se conoce como el problema de los gradientes avanescentes y puede dificultar mucho el entrenamiento de redes profundas.</p></li>
</ul>
<p>La <strong>función softmax</strong>, que también produce salidas acotadas entre 0 y 1, sufre saturación de manera similar.</p>
<p>Por tanto, ambas funciones de activación no son ideales para capas ocultas y es mejor utilizarlas solo en la última capa.</p>
</section>
<section id="relu" class="level3">
<h3 class="anchored" data-anchor-id="relu">ReLU</h3>
<p>Descubriremos dos funciones de activación ampliamente utilizadas, diseñadas para su uso entre capas lineales o en capas ocultas.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig43.png" class="img-fluid figure-img" width="300"></p>
<figcaption>Función ReLU</figcaption>
</figure>
</div>
<ul>
<li><p><span class="math inline">\(f(x) = \max(x,0)\)</span> aquí está la unidad lineal rectificada o ReLU. ReLU genera el valor máximo entre su entrada y cero. Como se muestra en el gráfico.</p></li>
<li><p>Para <strong>entradas positivas,</strong> la salida es igual a la entrada.</p></li>
<li><p>Para <strong>entradas negativas,</strong> la salida es cero.</p></li>
</ul>
<p>Esta función no tiene límite superior y sus gradientes no se aproximan a cero. Para valores grandes de <span class="math inline">\(x\)</span>, lo que ayuda a superar el problema de los gradientes que desaparecen.</p>
<p>En PyTorch, ReLU se puede utilizar a través del módulo torch.nn</p>
<div id="736414ee" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>relu <span class="op">=</span> nn.ReLU()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="leaky-relu-relu-con-fugas" class="level3">
<h3 class="anchored" data-anchor-id="leaky-relu-relu-con-fugas">Leaky ReLU (ReLU con fugas)</h3>
<p>La ReLU con fugas es una variación de la función ReLU. Para entradas positivas, se comporta exactamente como ReLU.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig44.png" class="img-fluid figure-img" width="300"></p>
<figcaption>Leaky ReLU</figcaption>
</figure>
</div>
<ul>
<li><p>Para <strong>entradas positivas</strong>, se comporta exactamente como ReLU.</p></li>
<li><p>Para <strong>entradas negativas</strong>, multiplica la entrada por un coeficiente pequeño (predeterminado a 0.01 en PyTorch).</p></li>
</ul>
<p>Esto garantiza que los gradientes para entradas negativas permanezcan distintos de cero, lo que evita que las neuronas dejen de aprender por completo, lo que puede suceder con ReLU estándar.</p>
<p>En PyTorch, la función ReLU con fugas se implementa utilizando el módulo torch.nn.</p>
<div id="7bef4024" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>leaky_relu <span class="op">=</span> nn.LeakyReLU(</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>  negative_slope <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El parámetro <strong>negative_slope</strong> controla el coeficiente aplicado a las entradas negativas.</p>
</section>
</section>
<section id="tasa-de-aprendizaje" class="level2">
<h2 class="anchored" data-anchor-id="tasa-de-aprendizaje">Tasa de Aprendizaje</h2>
<p>Hemos hablado anteriormente sobre la tasa de aprendizaje, pero llego el momento de que profundicemos más.</p>
<section id="actualización-de-pesos-con-sgd" class="level3">
<h3 class="anchored" data-anchor-id="actualización-de-pesos-con-sgd">Actualización de Pesos con SGD</h3>
<ul>
<li><p>Entrenar una red neuronal significa = resolver una optimización. El problema planteado es minimizar la función de pérdida y ajustando los parámetros del modelo.<br>
<br>
</p>
<ul>
<li>Para ello utilizamos un algoritmo llamado <strong>descenso de gradiente estocástico, o SGD</strong>, implementado en PyTorch.</li>
</ul>
<div id="47bd4627" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>sgd <span class="op">=</span> optim.SGD(model.parameters(), lr <span class="op">=</span> <span class="fl">0.01</span>, momentum <span class="op">=</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Recuerde que este es el optimizador que usamos para encontrar el mínimo global de las funciones de pérdida.</p></li>
<li><p>El optimizador toma los parámetros del modelo junto con dos argumentos claves:<br>
<br>
</p>
<ul>
<li><strong>Tasa de aprendizaje:</strong> controla el tamaño del paso de las actualizaciones.<br>
<br>
</li>
<li>momentum: añade inercia para ayudar al optimizador a moverse con suavidad y evitar atascarse.<br>
</li>
</ul></li>
</ul>
</section>
<section id="impaco-de-learning-rate-tasa-de-aprendizaje-óptima" class="level3">
<h3 class="anchored" data-anchor-id="impaco-de-learning-rate-tasa-de-aprendizaje-óptima">Impaco de learning rate: tasa de aprendizaje óptima</h3>
<p>Comprender su impacto nos ayuda a optimizar la eficiencia.</p>
<p>Intentemos encontrar el mínimo de una función en forma de U.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig45.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="500"></p>
</figure>
</div>
<p>Comenzamos en <span class="math inline">\(x = -2\)</span> y ejecutamos el optimizador SGD durante diez pasos. Luego de estos pasos observamos que el optimizador está cerca del mínimo.</p>
<p>También podemos observar que a medida que nos acercamos al mínimo, el tamaño del paso disminuye gradualmente. Esto sucede porque el tamaño del paso es el gradiente multiplicado por la tasa de aprendizaje. Como la función es menos pronunciada cerca de cero, el gradiente, y por tanto el tamaño del paso, se hace más pequeño.</p>
</section>
<section id="impacto-de-learning-rate-tasa-de-aprendizaje-pequeña" class="level3">
<h3 class="anchored" data-anchor-id="impacto-de-learning-rate-tasa-de-aprendizaje-pequeña">Impacto de learning rate tasa de aprendizaje pequeña</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig46.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="600"></p>
</figure>
</div>
<p>Sin embargo, si utilizamos el mismo algoritmo para un aprendizaje, si reducimos la velocidad diez veces, nos damos cuenta de que todavía estamos lejos del mínimo de la función después de diez pasos. El optimizador tardará mucho más tiempo en encontrar el mínimo de la función.</p>
</section>
<section id="impacto-learning-rate-tasa-de-aprendizaje-alto" class="level3">
<h3 class="anchored" data-anchor-id="impacto-learning-rate-tasa-de-aprendizaje-alto">Impacto learning rate: tasa de aprendizaje alto</h3>
<p>Si utilizamos un valor alto para la tasa de aprendizaje, observamos que el optimizador no puede encontrar el mínimo y rebota de un lado a otro en ambos lados de la función.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig47.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="600"></p>
</figure>
</div>
<p>Recuerde que las funciones de pérdida no son convexas.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig48.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="800"></p>
</figure>
</div>
<p>Uno de los desafíos al intentar encontrar el mínimo de una función no convexa es quedarse atrapado en un mínimo local.</p>
</section>
<section id="sin-momentum" class="level3">
<h3 class="anchored" data-anchor-id="sin-momentum">Sin momentum</h3>
<ul>
<li><p><span class="math inline">\(lr = 0.01\)</span> <span class="math inline">\(momentum = 0\)</span>, ejecutemos nuestro optimizador durante 100 pasos con un momento nulo en esta función no convexa para <span class="math inline">\(x = -1.23\)</span> y <span class="math inline">\(y = -0.14\)</span>.<br>
<br>
<img src="img/fig49.png" class="img-fluid" width="500"></p>
<ul>
<li>Vemos que el optimizador se queda atascado en esta primera caída de la función, que no es su mínimo global.</li>
</ul></li>
<li><p>Sin embargo, al utilizar lr = 0.01, momentum = 0.9 ejecutando nuestro optimizador durante 100 pasos para <span class="math inline">\(x = 0.92\)</span> y <span class="math inline">\(y = -2.04\)</span>. Podemos encontrar el mínimo de la función.<br>
<br>
<img src="img/fig50.png" class="img-fluid" width="500"></p></li>
</ul>
<p>Este parámetro proporciona impulso al optimizador permitiendole superar caídas locales, como se muestra en la figura previa.</p>
<p>El impulso (momentum) mantiene el tamaño del paso grande cuando los pasos anteriores también fueron grandes, incluso si el gradiente actual es pequeño.</p>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<p>Enr esumen, dos parámetros optimizadores clave impactan el entrenamiento: la tasa de aprendizaje (learning rate) y el impulso (momentum):</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Learning Rate</th>
<th>Momentum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Controla el tamaño del paso</td>
<td>Controla la inercia</td>
</tr>
<tr class="even">
<td>Valor de tasa alta -&gt; bajo rendimiento</td>
<td>Ayuda a escapar de mínimos locales</td>
</tr>
<tr class="odd">
<td>Valor de tasa bajo -&gt; entrenamiento lento</td>
<td>Demasiado pequeño -&gt; el optimizador se queda atascado</td>
</tr>
<tr class="even">
<td>Valores tipicos varían de 0.01 a 0.0001.</td>
<td>Rango típico: 0.85 a 0.99</td>
</tr>
</tbody>
</table>
<p><strong>El <code>momentum</code> y <code>learning</code> rate son críticos par el entrenamiento de tu red neuronal. Una buena regla general es comenzar con una learning rate de 0.001 y un momentum de 0.95.</strong></p>
</section>
</section>
</section>
<section id="evaluación-y-mejora-de-los-modelos" class="level1">
<h1>Evaluación y Mejora de los Modelos</h1>
<p>Entrenar un modelo de aprendizaje profundo es un arte, y para asegurarnos de que nuestro modelo se entrene correctamente, necesitamos hacer un seguimiento de ciertos parámetros durante el entrenamiento, como la pérdida o la exactitud. Aprenderemos a calcular estas métricas y a reducir el sobreajuste.</p>
<section id="inicialización-de-capas-y-aprendizaje-por-transferencia" class="level3">
<h3 class="anchored" data-anchor-id="inicialización-de-capas-y-aprendizaje-por-transferencia">Inicialización de capas y aprendizaje por transferencia</h3>
<p>Hemos explorado cómo las redes neuronales aprenden actualizando los pesos durante el entrenamiento. Este capítulo final analizará técnicas para evaluar y mejorar la eficiencia del rendimiento del modelo.</p>
<p>Antes de comenzar, tenga en cuenta que los temas aquí son más avanzados y los cubriremos aun alto nivel.</p>
<section id="inicialización-de-capa" class="level4">
<h4 class="anchored" data-anchor-id="inicialización-de-capa">Inicialización de Capa</h4>
<p>La normalización de datos escala las características de entrada para lograr estabilidad; de manera similar, los pesos de una capa lineal también se inicializan en valores pequeños. Esto se conoce como inicialización de capa.</p>
<p>Creemos una pequeña capa lineal y verifiquemos su rango de peso.</p>
<div id="e3cdc6de" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn </span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>layer <span class="op">=</span> nn.Linear(<span class="dv">64</span>, <span class="dv">128</span>)</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(layer.weight.<span class="bu">min</span>(), layer.weight.<span class="bu">max</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor(-0.1250, grad_fn=&lt;MinBackward1&gt;) tensor(0.1250, grad_fn=&lt;MaxBackward1&gt;)</code></pre>
</div>
</div>
<p>Observemos que los pesos están entre -0.1250 y <span class="math inline">\(\pm\)</span> 0.125</p>
</section>
<section id="por-qué-es-esto-importante" class="level4">
<h4 class="anchored" data-anchor-id="por-qué-es-esto-importante">Por qué es esto importante?</h4>
<p>La salida de una neurona en una capa lineal es una suma ponderada de las entradas de la capa anterior.</p>
<p>Mantener pequeños tanto los datos de entrada como los pesos de las capas garantiza salidas estables, evitando valores extremos que podrían ralentizar el entrenamiento.</p>
<p>Las capas de pueden inicializar de diferentes maneras y sigue siendo un área de investigación activa.</p>
<p>PyTorch proporciona una forma sencilla de inicializar los pesos de las capas con el módulo <code>nn.init.</code></p>
<div id="40615c01" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>layer <span class="op">=</span> nn.Linear(<span class="dv">64</span>, <span class="dv">128</span>)</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>nn.init.uniform_(layer.weight)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(layer.weight.<span class="bu">min</span>(), layer.weight.<span class="bu">max</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor(6.4969e-05, grad_fn=&lt;MinBackward1&gt;) tensor(1.0000, grad_fn=&lt;MaxBackward1&gt;)</code></pre>
</div>
</div>
<p>Por ejemplo, aquí inicializamos una capa lineal con una distribución uniforme. Como puedes ver, los valores de los pesos ahora varían de 0 a 1.</p>
</section>
</section>
<section id="aprendizaje-por-transferencia" class="level3">
<h3 class="anchored" data-anchor-id="aprendizaje-por-transferencia">Aprendizaje por Transferencia</h3>
<p>En la práctica, los ingenieros rara vez entrenan un modelo a partir de pesos inicializados aleatoriamente. En lugar de ello, se basan en un concepto llamado aprendizaje por transferencia.</p>
<p>El aprendizaje por transferencia toma un modelo que fue entrenado en una primera tarea y lo reutiliza para una segunda tarea. Por ejemplo, entrenamos un modelo sobre los salarios de los científicos de datos en EE.UU.</p>
<p>Ahora tenemos nuevos datos de los salarios en Europa. En lugar de entrenar un modelo usando pesos inicializados aleatoriamente, podemos cargar los pesos del primer modelo y usarlos como punto de partida para entrenar en este nuevo conjunto de datos.</p>
<p>Se pueden guardar y cargar pesos utilizando las funciones <code>torch.save</code> y <code>torch.load</code></p>
<pre class="{bash}"><code>import torch

layer = nn.Linear(64, 128)
torch.save(layer, 'layer.pth')

new_layer = torch.load('layer.pth')</code></pre>
<p>Estas funciones funcionan en cualquier tipo de objetos de PyTorch.</p>
</section>
<section id="ajuste-fino" class="level3">
<h3 class="anchored" data-anchor-id="ajuste-fino">Ajuste Fino</h3>
<p>A veces, la segunda tarea es similar a la primera tarea: queremos realizar un tipo específico de aprendizaje por transferencia llamado ajuste fino.</p>
<p>En este caso, cargamos pesos de un modelo previamente entrenado, pero entrenamos el modelo con una tasa de aprendizaje más pequeña.</p>
<p>Incluso podemos entrenar parte de una red, si decidimos que alguna de las capas de red no necesitan ser entrenadas y elige congelarla.</p>
<p>Una regla general es congelar las primeras capas de la red y ajustar las capas más cercanas a la capa de salida.</p>
<p>Esto se puede lograr estableciendo el atributo <code>requires_grad</code> de cada parámetro en Falso.</p>
<div id="285269da" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(nn.Linear(<span class="dv">64</span>, <span class="dv">128</span>),</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>nn.Linear(<span class="dv">128</span>, <span class="dv">256</span>))</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, param <span class="kw">in</span> model.named_parameters():</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> name <span class="op">==</span> <span class="st">'0.weight'</span>:</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    param.requires_grad <span class="op">=</span> <span class="va">False</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aquí, utilizamos el método <code>named_parameters()</code> del modelo, que devuelve el nombe y el parámetro en sí.</p>
</section>
<section id="evaluación-del-rendimiento-de-los-modelos" class="level2">
<h2 class="anchored" data-anchor-id="evaluación-del-rendimiento-de-los-modelos">Evaluación del Rendimiento de los Modelos</h2>
<p>Hemos realizado mucho entrenamiento. Ahora vamos a evaluar nuestros modelos. En el Machine Learning, los datos se dividen en conjuntos de entrenamiento, validación y prueba.</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>Training</td>
<td>80-90%</td>
<td>Ajusta los parámetros del modelo</td>
</tr>
<tr class="even">
<td>Validación</td>
<td>10 - 20%</td>
<td>Ajusta los hiperparámetros del model</td>
</tr>
<tr class="odd">
<td>Test</td>
<td>5 - 10%</td>
<td>Evalúa el rendimiento final del modelo</td>
</tr>
</tbody>
</table>
<p>Los datos de entrenamiento ajustan los parámetros del modelo, como pesos y sesgos, y los datos de validación ajustan hiperparámetros como la tasa de aprendizaje y el impulso, y el conjunto de pruebas evalúa el rendimiento final del modelo.</p>
<p>Realizaremos un seguimiento de dos métricas clave: pérdida y precisión durante el entrenamiento y la validación.</p>
<section id="calculando-pérdida-de-entrenamiento" class="level3">
<h3 class="anchored" data-anchor-id="calculando-pérdida-de-entrenamiento">Calculando Pérdida de Entrenamiento</h3>
<ul>
<li><p>La pérdida de entrenamiento se calcula sumando la pérdida de todos los lotes en el cargador de datos de entrenamiento.</p></li>
<li><p>Al final de cada época (epoch), calculamos la pérdida de entrenamiento media dividiendo la pérdida total por el número de epoch.</p></li>
</ul>
<pre class="{bash}"><code>training_loss = 0.0 

for inputs, labels in trainloader: 
  outputs = model(inputs)
  loss = criterion(outputs, labels)
  loss.backward()
  optimizer.step()
  optimizer.zero_grad()
  
  training_loss += loss.item()
  
epoch_loss = training_loss / len(trainloader)</code></pre>
<p>Iteramos a través del cargador de entranamiento, ejecutamos un pase hacia adelante y calculamos la pérdida. Como es habitual, el modelo calcula gradiente y actualiza pesos mediante retropropagación. Y agregamos cada valor de pérdida al total usando <code>.item()</code>, que extrae el valor numérico de u tensor.</p>
<p>Dqdo que una epoch es un paso completo a través del cargado de datos de entrenamiento, calculamos la pérdida media dividiendo training_loss por el número de lotes en el cargador de train.</p>
</section>
<section id="calculo-de-la-pérdida-de-validación" class="level3">
<h3 class="anchored" data-anchor-id="calculo-de-la-pérdida-de-validación">Calculo de la pérdida de validación</h3>
<p>Después de cada epoch de entrenamiento, ejecutamos un ciclo de validación.</p>
<ul>
<li><p>Primero, establecemos el modelo en modo evaluación usando <code>.eval(),</code> como algunas capas se comportan de manera diferente durante el entrenamiento y la validación.</p></li>
<li><p>Para mejorar la eficiencia, utilizamos <code>torch.no_grad()</code> , que deshabilita cálculos de gradiente ya que no actualizamos los pesos durante la validación.</p></li>
<li><p>Luego, iteramos a través del cargador de datos de validación, ejecutamos un pase hacia adelante y calculamos la pérdida, sumándola en los lotes.</p></li>
<li><p>Al final de la época, calculamos la pérdida de validación media.</p></li>
<li><p>Finalmente, volvemos al modo de entrenamiento con .<code>train()</code>, preparándolo para la siguiente epoch de entrenamiento.</p></li>
</ul>
<pre class="{bash}"><code>validation_loss = 0.0

model.eval()

with torch.no_grad(): 
  for inputs, labels in validationloader: 
    outputs = model(inputs)
    loss = criterion(outputs, labels)
    validation_loss += loss.item()
    
epoch_loss = validation_loss / len(validationloader) 
model.train()
</code></pre>
</section>
<section id="sobreajuste-o-overfitting" class="level3">
<h3 class="anchored" data-anchor-id="sobreajuste-o-overfitting">Sobreajuste o Overfitting</h3>
<p>Realizar un seguimiento de la pérdida de entrenamiento y validación nos ayuda a detectar el sobreajuste.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig51.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></p>
</figure>
</div>
<p><strong>Cuando un modelo se sobreajusta</strong>, la pérdida de entrenamiento continúa disminuyendo, pero la pérdida de validación comienza a aumentar. Esto significa que el <strong>modelo está aprendiendo demasiado bien los datos de entrenamiento</strong> y no funcionará bien con datos nuevos.</p>
</section>
<section id="calculando-accuracy-con-torchmetrics" class="level3">
<h3 class="anchored" data-anchor-id="calculando-accuracy-con-torchmetrics">Calculando accuracy con <code>torchmetrics</code></h3>
<p>La pérdida nos indica qué tan bien está aprendiendo un modelo, pero no siempre refleja con qué precisión hace predicciones.</p>
<ol type="1">
<li><p>Hacemos un seguimiento de la precisión utilizando torchmetrics.</p></li>
<li><p>Para tareas de clasificación de múltiples clases, creamos una métrica de precisión con <code>torchmetrics.Accuracy()</code></p></li>
<li><p>A medida que el modelo procesa cada lote, actualizamos esta métrica utilizando sus predicciones y las etiquetas reales.</p></li>
<li><p>Dado que el modelo genera probabilidades para múltiples clases, podemos utilizar <code>argmax(dim=-1)</code> para seleccionar la clase con mayor probabilidad. Esto convierte las predicciones codificadas one-hot en índices de clase antes de pasarlas a la métrica.</p></li>
<li><p>Al final de cada epoch, calculamos la precisión general utilizando <code>.compute().</code></p></li>
<li><p>Finalmente, reiniciamos la métrica con <code>.reset()</code> para borrar su estado antes de la próxima epoch.</p></li>
</ol>
<pre class="{bash}"><code>import torchmetrics 

metrics = torchmetrics.Accuracy(task = "multiclass", num_classes = 3)

for features, labels in dataloader: 
  outputs = model(features)
  metrics.update(outputs, labels.argmax(dim=-1))
  
accuracy = metrics.compute()

metric.reset()
</code></pre>
</section>
</section>
<section id="lucha-contra-el-sobreajuste" class="level2">
<h2 class="anchored" data-anchor-id="lucha-contra-el-sobreajuste">Lucha contra el Sobreajuste</h2>
<p>Anteriormente, aprendimos cómo detectar el sobreajuste observando las pérdidas de entrenamiento y validación. Ahora, descubriremos algunas formas de combatir el sobreajuste.</p>
<p>Recuerde que el sobreajuste ocurre cuando el modelo no se generaliza a datos no vistos. Si no entrenamos correctamente el modelo, comenzará a memorizar los datos de entrenamiento, lo que conduce a un buen rendimiento en el conjunto de entrenamiento pero a un rendimiento deficiente en el conjunto de validación.</p>
<p>Posibles causas:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Problema</th>
<th>Solución</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Conjunto de datos pequeños</td>
<td>Más data</td>
</tr>
<tr class="even">
<td>Modelo con demasiada capacidad</td>
<td>Reducir el tamaño del modelo</td>
</tr>
<tr class="odd">
<td>Valores grandes de los pesos</td>
<td>Reducir los valores de los pesos</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Para contrarrestar el sobreajuste, podemos reducir el tamaño del modelo o agregar un nuevo tipo de capa llamada <strong>dropout</strong>.</p></li>
<li><p>También podemos utilizar la descomposición del peso para forzar que los parámetros permanezcan pequeños.</p></li>
<li><p>Para obtener más datos o utilizar la ampliación de datos</p></li>
</ul>
<p>Exploremos estas estrategías.</p>
<section id="regularización-usando-una-capa-dropout" class="level3">
<h3 class="anchored" data-anchor-id="regularización-usando-una-capa-dropout">Regularización usando una capa dropout</h3>
<p>Una forma común de combatir el sobreajuste es agregar capas dropout a nuestra red neuronal.</p>
<p><code>El dropout</code> es una técnica de <strong>regularización</strong> que desactiva aleatoriamente una fracción de las neuronas durante el entrenamiento, evitando que el modelo se vuelva demasiado dependiente de características específicas.</p>
<ul>
<li>Las capas dropout normalmente se agregan después de las funciones de activación.</li>
</ul>
<div id="e7feb7c1" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(nn.Linear(<span class="dv">8</span>, <span class="dv">4</span>),</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>nn.ReLU(),</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>nn.Dropout(p <span class="op">=</span> <span class="fl">0.5</span>))</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> torch.randn((<span class="dv">1</span>, <span class="dv">8</span>))</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model(features))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.4203, 0.0000, 0.0000, 0.0000]], grad_fn=&lt;MulBackward0&gt;)</code></pre>
</div>
</div>
<p>El argumento <strong>p</strong> determina la probabilidad de que una neurona se establezca en cero. En este ejemplo se descartan el 75% de las neuronas.</p>
<p>El dropout se comporta de manera diferente durante el entrenamiento y la evaluación, durante el entrenamiento, desactiva neuronas aleatoriamente, mientras que durante la evaluación se deshabilita, lo que garantiza que todas las neuronas estén activas para obtener predicciones estables.</p>
<p>Para cambiar entre estos modos, utilizamos <code>model.train()</code> y <code>model.eval()</code></p>
</section>
<section id="regularización-con-disminución-de-pesos" class="level3">
<h3 class="anchored" data-anchor-id="regularización-con-disminución-de-pesos">Regularización con disminución de pesos</h3>
<p>La siguiente estratefia para reducir el sobreajuste que descubriremos es la disminución de pesos, otra forma de regularización.</p>
<p>En PyTorch, la disminución del peso se agreha al optimizador mediante el parámetro weight_decay, normalmente establecido en un valor pequeño, por ejemplo 0.0001. Este parámetro agrega una penalización a la función de pérdida, formando pesos más pequeños y ayudando al modelo a generalizar mejor.</p>
<pre class="{bash}"><code>optimizer = optim.SGD(model.parameters(), lr = 0.001, weight_decay = 0.0001)</code></pre>
<ul>
<li><p>Durante la retropropagación, esta penalización se resta del gradiente, lo que evita un crecimiento excesivo del peso.</p></li>
<li><p>Cuanto más alto fijemos la caída del peso, más fuerte será la regularización y hará que el sobreajuste sea menos probable.</p></li>
</ul>
</section>
<section id="aumentación-de-data" class="level3">
<h3 class="anchored" data-anchor-id="aumentación-de-data">Aumentación de Data</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig52.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="700"></p>
</figure>
</div>
<ul>
<li><p>Recopilar más datos puede ser costoso, pero los investigadores han encontrado una forma de expandir conjuntos de datos artificialmente usando <strong>aumento de datos</strong>.</p></li>
<li><p>El aumento de datos se aplica comúnmente a los datos de imágenes, que se pueden rotar y escalados, de modo que diferentes vistas de la misma cara estén disponibles como puntos de datos nuevos.</p></li>
<li><p>Si bien no analizaremos aquí como aumentar los datos, sigue siendo un método valioso para combatir el sobreajuste cuando no hay datos adicionales disponibles.</p></li>
</ul>
</section>
</section>
<section id="mejorar-el-rendimiento-del-modelo" class="level2">
<h2 class="anchored" data-anchor-id="mejorar-el-rendimiento-del-modelo">Mejorar el Rendimiento del Modelo</h2>
<p>En esta sessión final, reuniremos todo y aprenderemos una receta para abordar cualquier problema de Deep Learning.</p>
<ul>
<li><p>Primero, creamos un modelo que pueda sobreajustarse al conjunto de entrenamiento. Esto garantizará que el problema tenga solución. También establecemos un línea base de rendimiento a la que aspirar con el conjunto de validación.</p></li>
<li><p>Luego, necesitamos reducir el sobreajuste para aumentar el rendimiento en el conjunto de validación.</p></li>
<li><p>Por último, podemos ajustar ligeramente los diferentes hiperparámetros para garantizar que logremos el mejor rendimiento posible.</p></li>
</ul>
<p>Es útil comenzar con un solo punto de datos antes de sobreajustar todo el conjunto de entrenamiento.</p>
<pre class="{bash}"><code>features, labels = next(iter(dataloader))

for i in range(1000): 
  outputs = model(features)
  loss = criterion(outputs, labels)
  optimizer.zero_grad()
  loss.backward()
  optimizer.step()</code></pre>
<ul>
<li><p>Cuando el modelo está configurado correctamente, debería alcanzar rápidamente una pérdida a cero y una predicción del 100% en ese punto de datos. Una vez que este paso sea exitoso, escalamos al conjunto de entrenamiento completo.</p></li>
<li><p>En esta etapa, utilizamos una arquitectura de modelo existente lo suficientemente grande como para sobreajustar mientras mantiene los hiperparámetros, como la tasa de aprendizaje, en sus valores predeterminados.</p></li>
</ul>
<p>Ahora necesitamos crear un modelo que se generalice bien para maximizar la precisión de la validación.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig53.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></p>
</figure>
</div>
<p>Reducir el sobreajuste a menudo tiene un costo, ya que aplicar la regularización puede afectar significativamente el rendimiento del modelo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig54.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="800"></p>
</figure>
</div>
<p>El modelo original se ajusta al conjunto de entrenamiento, logrando una alta precisión pero sin generalizarse bien a datos nuevos. Por el contrario, con demasiada regularización, el modelo actualizado muestra una caída en la precisión del entrenamiento y la validación, lo que limita su capacidad de aprender de manera efectiva. Esto resalta la importancia de equilibrar la reducción del sobreajuste.</p>
<p>Estrategías mientras monitoreamos de cerca las métricas clave para encontrar el modelo con mejor rendimiento.</p>
<p>Una vez que estemos satisfechos con el rendimiento, el paso final es ajustar los hiperparámetros. Esto se hace a menudo en configuraciones del optimizador, como la tasa de aprendizaje o el impulso.</p>
<p>La busqueda de cuadrícula prueba parámetros a intervalos fijos. Por ejemplo, valores de impulso de 0.85 a 0.99 y tasas de aprendizaje de diez elvado a menos seís</p>
<div id="65f2cf9b" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Grid Search</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> factor <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">6</span>): </span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>  lr <span class="op">=</span> <span class="dv">10</span> <span class="op">**</span> <span class="op">-</span>factor</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig55.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="300"></p>
</figure>
</div>
<p>La búsqueda aleatoria adopta un enfoque diferente. En lugar de probar valores establecidos, los seleccionamos aleatoriamente dentro de un rango determinado. La función <code>np.random.uniform(2, 6)</code>, por ejemplo, elige un número entre 2 y 6, lo que nos permite explorar una variedad más amplia de ritmos de aprendizaje.</p>
<div id="816d0af0" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>factor <span class="op">=</span> np.random.uniform(<span class="dv">2</span>, <span class="dv">6</span>)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>lr <span class="op">=</span> <span class="dv">10</span><span class="op">**</span> <span class="op">-</span> factor</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fig56.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="300"></p>
</figure>
</div>
<p>La búsqueda aleatoria suele ser más eficiente, ya que evita pruebas innecesarias y aumenta la posibilidad de encontrar configuraciones óptimas.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/j-isaula\.github\.io\/Web_JI\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="Isaula/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2022 Juan Isaula</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>